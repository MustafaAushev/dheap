# Реализация приоритетной очереди на основе d-кучи, упорядоченной таблицы и бинарного поискового дерева и её применение для построения остовного дерева графа с помощью алгоритма Краскала

## Содержание

* [Постановка задачи](#Постановка-задачи)
* [Руководство пользователя](#Руководство-пользователя)
	* [Использование реализации пирамидальной сортировки](#Использование-реализации-пирамидальной-сортировки)
    * [Использование реализации алгоритма Дейкстры](#Использование-реализации-алгоритма-Дейкстры)
	* [Использование реализации алгоритма Краскала](#Использование-реализации-алгоритма-Краскала)
* [Руководство программиста](#Руководство-программиста)
	* [Используемые технологии](#Используемые-технологии)
	* [Общая структура репозитория](#Общая-структура-репозитория)
	* [Описание структуры решения](#Описание-структуры-решения)
	* [Описание структур данных](#Описание-структур-данных)
		* [D-куча](#d-куча)
		* [Бинарное поисковое дерево](#Бинарное-поисковое-дерево)
		* [Таблицы](#Таблицы)
			* [Просматриваемые таблицы](#Просматриваемые-таблицы)
			* [Упорядоченные таблицы](#Упорядоченные-таблицы)
		* [Приоритетные очереди](#Приоритетные-очереди)
      * [Разделенные множества](#Разделенные-множества)
	* [Описание алгоритмов](#Описание-алгоритмов)
		* [Пирамидальная сортировка](#Пирамидальная-сортировка)
		* [Алгоритм Дейкстры](#Алгоритм-Дейкстры)
		* [Алгоритм Краскала](#Алгоритм-Краскала)
	* [Программная реализация структур данных](#Программная-реализация-структур-данных)
		* [Программная реализация d-кучи](#Программная-реализация-d-кучи)
		* [Программная реализация бинарного поискового дерева](#Программная-реализация-бинарного-поискового-дерева)
		* [Программная реализация просматриваемых таблиц](#Программная-реализация-просматриваемых-таблиц)
		* [Программная реализация упорядоченных таблиц](#Программная-реализация-упорядоченных-таблиц)
		* [Программная реализация приоритетной очереди на основе D-кучи](#Программная-реализация-приоритетной-очереди-на-основе-d-кучи)
		* [Программная реализация приоритетной очереди на основе бинарного поискового дерева](#Программная-реализация-приоритетной-очереди-на-основе-бинарного-поискового-дерева)
		* [Программная реализация приоритетной очереди на основе упорядоченной таблицы](#Программная-реализация-приоритетной-очереди-на-основе-упорядоченной-таблицы)
		* [Программная реализация разделенных множеств](#Программная-реализация-разделенных-множеств)
		* [Программная реализация графа](#Программная-реализация-графа)
* [Заключение](#Заключение)
* [Литература](#Литература)


##Постановка задачи

1. Разработать статические библиотеки, реализующие следующие структуры данных:
	- d-кучу;
	- бинарное поисковое дерево;
	- граф;
	- разделенные множества;
	- таблицу;
	- просматриваемую таблицу;
	- упорядоченную таблицу;
	- приоритетную очередь, основанную на d-куче;
	- приоритетную очередь, основанную на бинарном поисковом дереве;
	- приоритетную очередь, основанную на упорядоченной таблице.
2. Написать тестирующую программу для каждого метода каждой структуры данных с помощью Google C++ Testing Framework.
3. Написать приложение для демонстрации работы d-кучи (пирамидальная сортировка).
4. Написать приложение для демонстрации работы приоритетной очереди, основанной на d-куче (алгоритм Дейкстры):
	- входные данные - связный неориентированный взвешенный граф без петель со стартовой вершиной;
	- выходные данные:
	    - список вершин;
	    - список кратчайших путей до каждой вершины графа;
	    - список предшествующий вершин.
5. Написать приложение для демонстрации работы приоритетных очередей (на базе D-кучи, бинарного поискового дерева и упорядоченной таблицы) и разделенных множеств (алгоритм Краскала):
	* входные данные - связный неориентированный взвешенный граф без петель;
	* выходные данные - граф, представляющий минимальное остовное дерево для исходного графа.

##Руководство пользователя

###Использование реализации пирамидальной сортировки

####Запуск приложения и ввод данных

Программа предназначена для сортировки D-кучи.
Для запуска приложения нужно открыть исполняемый файл `sample_sort.exe`.
Программа запросит арность кучи и количество элементов. Программа автоматически заполнит дерево, с учетом ваших данных, и на экран выведется сначала исходная куча, затем отсортированная.

####Пример:

1) После запуска программы необходимо ввести арность кучи:

![1](/img/sort1.png)

2) Затем необходимо ввести размер кучи:

![2](/img/sort2.png)

3) После этого программа выведет исходную и отсортированную кучу:

![3](/img/sort3.png)

###Использование реализации алгоритма Дейкстры

####Запуск приложения и ввод данных

Программа предназначена для поиска кратчийших путей во взвешенном неориентированном графе от любой вершины до всех остальных вершин графа.
Для запуска приложения нужно открыть исполняемый файл `sample_Dijkstra.exe`.
Программа попросит ввести количество вершин графа и количество ребер. Затем необходимо ввести минимальное и максимальное значения весов ребер. Также будет запрошен номер стартовой вершины. Результатом будет вывод номеров всех вершин, кратчайших путей от стартовой вершины и номеров предшествующих вершин.

####Пример:

1) Необходимо ввести количество вершин графа:

![4](/img/d1.png)

2) Затем необходимо ввести количество ребер графа:

![5](/img/d2.png)

3) После этого необходимо ввестиминимальное и максимальное значения весов рёбер графа:

![6](/img/d3.png)

4) Теперь необходимо выбрать стартовую вершину и получить результат:

![7](/img/d4.png)


###Использование реализации алгоритма Краскала

####Запуск приложения и ввод данных

Программа предназначена для построения минимального остовного дерева для взвешенного неориентированного графа. 
Для запуска приложения нужно открыть исполняемый файл `sample_Kruskal.exe`.
Программа попросит выбрать структуру данных, на которой будет основоваться приоритетная очередь, и количество вершин графа. Затем попросит выбрать, каким образом заполнять граф: случайным образом или вручную. Результатом работы программы будет вывод списка ребер, составляющих минимальное остовное дерево, и их весов.

####Пример

1) Выбираем структуру данных для приоритетной очереди:

![8](/img/kruskal1.png)

2) Вводим количество вершин и количество рёбер графа:

![9](/img/kruskal2.png)

3) Выбираем способ заполнения графа (в данном случае ручной ввод):

![10](/img/kruskal3.png)

Если выбрать автоматическое заполнение графа, программа запросит минимальное и максимальное значение графа.

4)Вводим необходимые данные:

![11](/img/kruskal4.png)

5) Программа завершила работу и вывела результат на экран:

![12](/img/kruskal5.png)


##Руководство программиста

###Используемые технологии

В ходе выполнения работы использованы следующее ПО:
- Среда разработки Microsoft Visual Studio 2015.
- Фреймворк для написания автоматических тестов Google Test.
- Система контроля версий Git.

###Общая структура репозитория

Репозиторий содержит следующие директории и файлы:

* [`gtest`](https://github.com/anna-kulikova/mp2-lab4-graph/tree/graph/gtest) - библиотека GoogleTest.
* [`include`](https://github.com/anna-kulikova/mp2-lab4-graph/tree/graph/include) - директория для размещения заголовочных файлов и реализаций структур данных.
* [`sample_Dijkstra`](https://github.com/anna-kulikova/mp2-lab4-graph/tree/graph/sample_Dijkstra) - директория для размещения исходного кода приложения алгоритма Дейкстры.
* [`sample_Kruskal`](https://github.com/anna-kulikova/mp2-lab4-graph/tree/graph/sample_Kruskal) - директория для размещения исходного кода приложения алгоритма Краскала.
* [`sample_sort`](https://github.com/anna-kulikova/mp2-lab4-graph/tree/graph/sample_sort) - директория для размещения исходного кода приложения пирамидальной сортировки.
* [`test`](https://github.com/anna-kulikova/mp2-lab4-graph/tree/graph/test) - директория для размещения тестов.
* [`sln`](https://github.com/anna-kulikova/mp2-lab4-graph/tree/graph/sln/vc14) - директория с файлими решений (на данный момент Visual Studio 2015).
* [`img`](https://github.com/anna-kulikova/mp2-lab4-graph/tree/graph/img) - директория с изображениями для отчета;
* [`src`](https://github.com/anna-kulikova/mp2-lab4-graph/tree/graph/src) - директория для размещения реализационных файлов

###Описание структуры решения

Решение состоит из 12 проектов:

* `Binary_tree` - статическая библиотка, содержащая объявление и реализацию шаблонного класса `Binary_search_tree`.
* `D_Heap` - статическая библиотека, содержащая объявление и реализацию шаблонного класса `D_heap`.
* `Graph` - статическая библиотека, содержащая объявление и реализацию шаблонного классов `Graph`.
* `gtest` - фреймворк Google Test.
* `Disjoint_set` - статическая библиотека, содержащая объявление и реализацию шаблонного класса разделенных множестве `Disjoint_set`.
* `Algorithm` - статическая библиотека, содержащая объявление и реализацию шаблонных классов алгоритма Краскала `Kruskal` и Дейкстры `Dijkstra`.
* `Priority Queue` - статическая библиотека, содержащая объявление и реализацию виртуального шаблонного класса приоритетной очереди и шаблонных классов-наследников приоритетных очередей, основанных на д-куче, бинарном поисковом дереве и упорядоченной таблице `Priority_queue`, `Queue_on_heap`, `Queue_on_tree`, `Queue_on_table`.
* `sample_Dijkstra` - консольное приложение для демонстрации работы алгоритма Дейкстры.
* `sample_Kruskal` - консольное приложение для демонстрации работы алгоритма Краскала.
* `sample_sort` - консольное приложение для демонстрации работы пирамидальной сортировки.
* `Table` - статическая библиотека, содержащая объявление и реализацию шаблонных классов `TabRecord`, `Table`, `ScanTable`, `SortTable`.
* `test` - консольное приложение для проверки правильности реализации классов `Binary_search_tree`, `D_heap`, `Graph`, `Queue_on_heap`, `Queue_on_tree`, `Queue_on_table`, `Disjoint_set`, `Scan_table`, `Sort_table`.


###Описание структур данных

####D-куча
D-куча - завершенное d-арное дерево, содержащее набор однотипных элементов, со следующими свойствами:
- каждый узел, не являющийся листом, за исключением, быть может, одного имеет ровно d потомков. Один узел, являющийся исключением, может иметь от 1 до d-1 потомка;
- если h - глубина дерева, то для любого i = 1, ..., k-1 такое дерево имеет ровно d^i узлов глубины i;
- количество узлов глубины k в дереве глубины k может варьироваться от 1 до d^k;
- каждый узел имеет вес. Иначе говоря, каждому узлу дерева присвоен ключ такого типа данных, на котором определен порядок сравнения;
- ключ элемента, приписанного узлу i, не превосходит ключа любого из своих потомков.

######Основные операции
* Транспонирование `Swap` (трудоемкость = O(1))
```
ТРАНСПОНИРОВАНИЕ(i, j)
{
	tmp = key[i];
	key[i] = key[j];
	key[j] = tmp;
}
```
* Всплытие `SiftUp` (трудоемкость = log(n)):
```
ВСПЛЫТИЕ(i)
{
	p = (i - 1) / d;
	while (i != 0 && key[p] > key[i])
	{	
		ТРАНСПОНИРОВАНИЕ(i, p);
		i = p;
		p = (i - 1) / d;
	}
}
```
* Погружение `SiftDown` (трудоемкость = О(d*log(n)):
```
ПОГРУЖЕНИЕ(i)
{
	с = minchild(i); 
	while (i != 0 && key[c] < key[i]){
		ТРАНСПОНИРОВАНИЕ(i, c);
		i = c;
		c = minchild(c);
	}
}
```
* Вставка элемента `Push` (трудоемкость = О(log(n)):
```
ВСТАВКА(x)
{
	key[size] = x;
	ВСПЛЫТИЕ(size);
	size++;
}
```
* Удаление элемента c минимальным ключом `RemoveMin` (трудоемкость = О(log(n)):
```
УДАЛЕНИЕ_С_МИНИМАЛЬНЫМ_КЛЮЧОМ()
{
	key[0] = key[size - 1];
	size--;
	ПОГРУЖЕНИЕ(0);
}
```
* Удаление элемента с заданным ключом `Remove` (трудоемкость = О(log(n)):
```
УДАЛЕНИЕ(i)
{
	key[i] = key[size - 1];
	size--;
	ПОГРУЖЕНИЕ(i);
}
```
* Окучивание `Heapify` (трудоемкость = О(log(n)):
```
ОКУЧИВАНИЕ()
{
	for(int i = size - 1; i >= 0; i--)
	ПОГРУЖЕНИЕ(i);
}
```

* Индекс минимального ребенка `MinChild` (трудоемкость = O(1)):
```
MINCHILD(i)
{
	minс = a * d + 1;
	if (a * d + d < count - 1)
		maxc = a * d + d;
	else
	  maxc = count - 1;
  for (int i = minc; i <= maxc; i++)
        if (keys[i] < keys[minc]) 
            minc = i;
}
```

####Бинарное дерево

#####Бинарное поисковое дерево
Бинарное поисковое дерево - это двоичное дерево, обладающее следующими свойствами:
* каждый узел имеет не больше двух потомков;
* любое поддерево является бинарным поисковым деревом;
* значение ключа любого узла левого поддерева меньше значения ключа корневого узла;
* значение ключа любого узла правого поддерева больше значения ключа корневого узла.
 
######Основные операции
* Вставка элемента `Push` (трудоемкость = log(n)):
```
ВСТАВКА(Node)
{
	y = 0;
	x = root;
	while(x != 0)
	{
		y = x;
		if (node->key < x->key) x = x->left;
		else x = x->right;
	}
	node->parent = y;
	if (y == 0) 
		root = node;
	else if (node->key < y->key) 
		y->left = node;
	else y->right = node;
}
```
* Удаление элемента `Remove` (трудоемкость = log(n)):
```
УДАЛЕНИЕ(key)
{
	node = МИНИМУМ();
	if (node->parent == 0) 
	{
		if (node->right_ == 0)
		{
			root = 0;
			delete node;
		}
		root = node->right;
		root->parent = 0;
		node->right = 0;
		delete node;
	}
	node->parent->left = node->right;
	node->right = node->parent = NULL;
	delete node;
}
```
* Поиск элемента `FindKey` (трудоемкость = n):
```
ПОИСК(key)
{
	node = root;
	while(node != 0 && node->key != key)
	{
		if (node->key > key) 
			node = node->left;
		else 
			node = node->right;
	}
	return node;
}
```
* Обход в прямом порядке `WorkAroundForward`:
```
ОБХОД_В_ПРЯМОМ_ПОРЯДКЕ(Node *tree)
{
	cout << key;
	ОБХОД_В_ПРЯМОМ_ПОРЯДКЕ(tree->left);
	ОБХОД_В_ПРЯМОМ_ПОРЯДКЕ(tree->right);
}
```
* Обход в обратном порядке `WorkAroundReverse`:
```
ОБХОД_В_ОБРАТНОМ_ПОРЯДКЕ(Node *tree)
{
	ОБХОД_В_ОБРАТНОМ_ПОРЯДКЕ(tree->left);
	ОБХОД_В_ОБРАТНОМ_ПОРЯДКЕ(tree->right);
	cout << key;
}
```
* Симметричный обход `WorkAroundSymmetric`:
```
СИММЕТРИЧНЫЙ_ОБХОД(Node *tree)
{
    	СИММЕТРИЧНЫЙ_ОБХОД(tree->left);
	cout << key;
	СИММЕТРИЧНЫЙ_ОБХОД(tree->right);
}
```
* Обход в ширину `WorkAroundWidth`:
```
ОБХОД_В_ШИРИНУ()
{
	queue <Node*> q;
	q.ВСТАВКА(tree);	
	while (q.empty() == 0)
	{
		Node tmp = q.front();
		cout << key;
		q.pop();		
		if (tmp->left != NULL)
			ВСТАВКА (tmp->left);
		if (tmp->right != NULL)
			ВСТАВКА (tmp->right);		
	}
}
```
* Обход в глубину `WorkAroundDepth`:
```
ОБХОД_В_ГЛУБИНУ
{
	stack<Node<KeyTYpe>*> s;
	s.push(tree);
	while (!s.empty() )
	{
		Node<KeyType>* tmp = s.top();
		cout << key;
		s.pop();
		if (tmp->right != NULL)
			ВСТАВКА(tmp->right);
		if (tmp->left != NULL)
			ВСТАВКА(tmp->left);
	}
}
```

####Таблицы

#####Просматриваемые таблицы
Таблица - динамическая структура данных, хранящая однотипные элементы. Записи хранятся в векторе памяти в порядке добавления (добавление производится в конец таблицы). При удалении записи просиходит перепаковка (сдвиг всех записей ниже текущей на одну позицию вверх).

######Основные операции
* Вставка `Push`:
```
ВСТАВИТЬ(record)
{
	recs[ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ] = record;
	ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ++;
}
```
* Удаление `Remove`:
```
УДАЛЕНИЕ(key)
{
	record = recs[0];
	tmp = 0;
	while ((recs[tmp]->GetKey() != key) && (tmp <= ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ))
		tmp++;
	if (tmp > ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ)
		return;
	recs[tmp] = recs[ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ - 1];
	recs[ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ - 1] = 0;
	ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ--;
}
```
* Поиск `FindKey`:
```
НАЙТИ(key)
{
	tmp = 0;
	while(КЛЮЧ(recs[tmp]) != key && tmp <= ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ)
		tmp += 1;
	if (tmp > ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ) 
		return 0;
	return recs[tmp];
}
```

#####Упорядоченные таблицы
Упорядоченная таблица - это просматриваемая таблица, данные в которой отсортированы по невозрастанию/неубыванию ключей. Причем при вставке и удалении происходят перепаковки.

######Основная операция
* Сортировка элементов `Sort` (трудоемкость = log(n)):
```
СОРТИРОВКА()
{
	TabRecord *tmp;
	for (int i=0; i<ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ; i++)
		for (int j = i+1; j<ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ; j++)
			if (recs[i]->GetKey() > recs[j]->GetKey() )
			{
				tmp = recs[i];
				recs[i] = recs[j];
				recs[j] = tmp;
			}
}
```

####Приоритетные очереди
Приоритетная очередь — это динамическая структура данных, содержащая элементы, каждый из которых имеет определенный приоритет. Элемент с более высоким приоритетом находится перед элементом с более низким приоритетом. Если у элементов одинаковые приоритеты, они располагаются в зависимости от своей позиции в очереди. 

######Основные операции:
* Вставка элемента `Push`.
* Удаление элемента с максимальным приоритетом `Pop`.
* Получение элемента с максимальным приоритетом `Top`.
* Проверка очереди на пустоту `IsEmpty`.
* Проверка очереди на полносту `IsFull`.

####Разделенные множества
Разледенные множества - абстрактный тип данных, предназначенный для представления коллекции k попарно непересекающихся можеств.

######Основные операции
* Создание множества `CreateSet` (трудоемкость = О(1)):
```
СОЗДАНИЕ_МНОЖЕСТВА(а)
{
	if (parent[a] != -1)
		return;
	parent[a] = a;
	height[a] = 0;
}
```
* Объединение множеств `UnionSet` (трудоемкость = О(n)):
```
ОБЪЕДИНЕНИЕ_МНОЖЕСТВ(a,b)
{
	a = ПОИСК_МНОЖЕСТВА (a);
	b = ПОИСК_МНОЖЕСТВА (b);
	if (height[a] > height[b])
		parent[b] = a;
	else if (height[a] < height[b])
		parent[a] = b;
	else
	{
		parent[b] = a;
		height[a]++;
	}
}
```
* Поиск множества `FindSet` (трудоемкость = О(1)):
```
ПОИСК_МНОЖЕСТВА(a)
{
	if (parent[a] == -1)
		return -1;
	while (parent[a] != a)
		a = parent[a];
	return a;
}
```

###Описание алгоритмов

####Пирамидальная сортировка
1. На вход поступает 2 значения: арность кучи и количество элементов.
2. Формируется куча с данными условиями.
3. Просматривается минимальный элемент кучи и кладется в результирующую кучу.
4. Минимальный элемент D-кучи меняется с последним.
5. Размер D-кучи уменьшаем на 1.
6. Погружаем нулевой элемент.
7. Если размер кучи положителен, переход к п.3, иначе алгоритм завершается.

Таким образом, возвращаемые значения будут отсортированы по возрастанию.

####Алгоритм Дейкстры

1. На вход поступает количество вершин, рёбер, минимальное и максимальное значение веса ребра.
2. Исходя из заданных условий формируется граф `graph`.
3. Задается стартовая вершина `s`.
4. Создается массив для отметки посещения вершины `vis`. Всем элементам (кроме `vis[s] = s`) присваивается -1.
5. Создается результирующий массив расстояний `dist` (все элементы равны `MAX`, `dist[s] = 0`).
6. Создается приоритетная очередь, в которую кладется расстояние от текущей вершины до неё же.
7. Вынимается минимальный элемент.
8. Если метка вынутого элемента больше метки, хранящейся в массиве `dist`, переходим к следующему шагу.
9. Проходим по всем ребрам от текущей вершины. Если результирующее расстояние от смежной вершины больше, чем результирующее расстояние до вынутой в пункте 7 вершины в сумме с меткой ребра, вынутого в пункте 9, то:
		- В `vis`  по номеру смежной вершины кладется значение вершины, вынутой на этапе 7.
		- В `dist` по номету смежной вершины пишется новое значение расстояния, равное сумме результирующего расстояния до вынутой в пункте 7 вершины и меткои ребра, вынутогов пункте 9.
		- Обработанное ребро кладется в очередь.
10. Выполняем пункты 7-9 до тех пор, пока очередь не опустеет.
11. На выходе получим 2 массива: 
    - Массив `dist` содержит кратчайшие расстояния до каждой вершины графа `graph`.
    - Массив `vis` содержит предшествующие вершины.

####Алгоритм Краскала

1. На вход поступает количество вершин `n`, рёбер, минимальное и максимальное значение веса ребра(если автоматическое заполнение).
2. Исходя из заданных условий формируется граф `graph`.
3. Создается приоритетная очередь из ребер графа `queue` (приоритет по весу ребра).
4. Создается разделенное множество из всех вершин `set`.
5. Вынимается ребро из приоритетной очереди.
6. Если вершины, вынутые из очереди не принадлежат одному множеству, то 2 множества (под номерами вершин) объдиняются, а данное ребро добавляется в результирующий граф `tree`.
7. Если количество вершин `tree` не превышает количество `n-1` и если очередь не пуста, то переходим к п.5, иначе алгоритм завершается.

В результате работы алгоритма имеется набор ребер и их весов, составляющих минимальное остовное дерево для данного графа.

###Программная реализация структур данных

####Схема наследования классов
![13](/img/Безымянный.png)

####Программная реализация d-кучи
В работе D-куча представлена классом `D_heap`, содержащим следующие поля:
- `int d` - арность дерева.
- `KeyType *keys` - массив ключей.
- `int count` - количество элементов.

Класс содержит следующие методы:
- `GetParent(int)` -  возвращает индекс родителя.
- `Swap(const int, const int)` - транспонирование 2-х елементов.
- `SiftUp(int)` - операция всплытия.
- `SiftDown(int)` - операция погружения.
- `MinChild(int)` - минимальный "ребенок".
- `RemoveMin()` - операция удаления минимального элемента.
- `Remove(int)` - операция удаления элемента с заданным индексом.
- `Push(KeyType)` - вставка элемента.
- `Heapify()` - операция окучивания.
- `Print()` - вывод кучи на экран.
- `operator==(const D_heap<KeyType>&)const` - проверка на равенство.
- `operator=(const _heap<KeyType>&)` - перегрузка оператора `=`.
- `GetCount()` - возвращает количество элементов в куче.
- `GetKey(KeyType)` - возвращает ключ заданного элемента.

####Программная реализация бинарного поискового дерева
Узел дерева представляется классом `Node`, содержащим следующие поля:
* `KeyType data` - данные.
* `Node<KeyType>* left` - указатель на левого потомка.
* `Node<KeyType>* right` - указатель на правого потомка.
* `Node<KeyType>* parent` - укаазатель на родителя.
* `int balance` - баланс поддерева.

Бинарное поисковое дерево представлено классом `Binary_search_tree`, содержащим следующие поля:
* `int size` - размер дерева.
* `Node<KeyType> *root` - указатель на корень дерева.

Класс содержит следующие методы:
* `Copy(Node<KeyType> *)` - копирование дерева.
* `Push(Node<KeyType>*&, const Node<KeyType> *)` - вставка элемента.
* `Remove(Node<KeyType>*&, const KeyType &)` - удаление элемента.
* `FindKey(Node<KeyType>*, const KeyType &)` - поиск элемента по ключу.
* `FindMax(Node<KeyType>*)` - поиск максимального элемента.
* `FindMin(Node<KeyType>*)` - поиск минимального элемента.
* `FindNext(Node<KeyType>*, Node<KeyType>*)` - поиск элемента, следующего за заданным.
* `FindPrevious(Node<KeyType>*, Node<KeyType>*)` - поиск элемента, предшествующего заданному.
* `WorkAroundWidth(Node<KeyType>*)` - обход в ширину.
* `WorkAroundForward(Node<KeyType>*)` - прямой обход.
* `WorkAroundReverse(Node<KeyType>*)` - обратный обход.
* `WorkAroundSymmetric(Node<KeyType>*)` - симметричный обход.
* `WorkAroundDepth(Node<KeyType>*)` - обход в глубину.
* `operator==(const bintree<KeyType>&)const` - проверка на равенство.
* `GetSize()` - возвращает количество элементов.
* `GetHeight(Node<KeyType>*)` - высота поддерева

####Программная реализация просматриваемых таблиц
Запись в таблице представлена классом `TabRecord`, содержащим следующие поля:
* `int key` - ключ.
* `KeyType data` - данные.

База для всех таблиц представлена классом `Table`, имеющим следующие поля:
* `int size` - размер таблицы.
* `int count` - количество записей в таблице.
* `int pos` - текущая позиция.

Класс содержит чисто виртуальные методы:
* `FindKey(int)` - поиск элемента по идентификатору.
* `Push(int, KeyType)` - вставка элемента.
* `Remove(int)` - удаление элемента
* `IsEmpty()` - проверка на пустоту.
* `IsFull()` - проверка на полноту.
* `GetCount()` - возвращает текущее количество записей.
* `Reset()` - сбрасывает указатель на `0`.
* `GoNext()` - переход к следующей записи.
* `IsTabEnded ()` - возвращает `1`, если таблица закончилась, и `0`, если нет.

Просматриваемые таблицы представлены классом `Scan_table`, содержащим поле:
* `TabRecord<KeyType>** recs` - записи в таблице.

Класс содержит следующие методы:
* `FindKey(int)` - поиск элемента.
* `Push(int, KeyType)` - вставка элемента.
* `Remove(int)` - удаление элемента.
* `Print()` - вывод таблицы на экран.

####Программная реализация упорядоченных таблиц
Упорядоченные таблицы наследуются от класса `Scan_table` и представлены классом `Sort_table`, содержащим следующие методы:
* `Sort()` - сортировка данных.
* `FindKey(int)` - поиск элемента.
* `Push(int, KeyType)` - вставка элемента.
* `Remove(int)` - удаление элемента.
* `Min()` - возвращает минимальный элемент.


####Программная реализация приоритетной очереди на основе D-кучи
Приоритетная очередь на основе D-кучи представлена классом `Queue_on_heap`, содержащим поле:
* `D_heap<KeyType> *heap` - указатель на кучу.

Класс содержит следующие методы:
* `Push(const KeyType)` - вставка элемента.
* `Pop()` - удаление элемента с максимальным приоритетом.
* `IsEmpty()` - проверка на пустоту.
* `IsFull()` - проверка на полноту.
* `Top()` - возвращает элемент с максимальным приоритетом.
* `Print()` - вывод очереди на экран.
* `GetSize ()` - возвращает количество элементов в очереди.
* `operator==(const Queue_on_heap<KeyType>&)const` - проверка на равенство.

####Программная реализация приоритетной очереди на основе бинарного поискового дерева
Приоритетная очередь на основе бинарного поискового дерева представлена классом `Queue_on_tree`, содержащим поле:
* `Binary_search_tree<KeyType> *tree` - указатель на дерево.

Класс содержит следующие методы:
* `Push(const KeyType)` - вставка элемента.
* `Pop()` - удаление элемента с максимальным приоритетом.
* `IsEmpty()` - проверка на пустоту.
* `IsFull()` - проверка на полноту.
* `Top()` - возвращает элемент с максимальным приоритетом.
* `Print()` - вывод очереди на экран.
* `GetSize ()` - возвращает количество элементов в очереди.
* `operator==(const Queue_on_tree<KeyType>&)const` - проверка на равенство.

####Программная реализация приоритетной очереди на основе упорядоченной таблицы
Приоритетная очередь на основе упорядоченной таблицы представлена классом `Queue_on_table`, содержащим поля:
* `Sort_table<KeyType>* table` - указатель на таблицу.
* `int s` - размер.

Класс содержит следующие методы:
* `Push(int, KeyType);` - вставка элемента.
* `Pop()` - удаление элемента с максимальным приоритетом.
* `IsEmpty()` - проверка на пустоту.
* `IsFull()` - проверка на полноту.
* `Top()` - возвращает элемент с максимальным приоритетом.
* `Print()` - вывод очереди на экран.
* `GetSize ()` - возвращает количество элементов в очереди.

####Программная реализация разделенных множеств
Разделенные множества представлены классом `Disjoint_set`, содержащим следующие поля:
* `int *parent` - указатель на родителя.
* `int *height` - высота.
* `int n` - размер.

Класс содержит следующие методы:
* `CreateSet(int)` - создает одноэлементное множество.
* `FindSet(int)` - возвращает главный элемент множества
* `UnionSet(int, int)` - объединяет множества.
* `Print()` - выводит множества на экран.
* `GetSet(int)` - возвращает массив, в котором: первый-элемент - количество элементов в данном множестве, последующие элементы - данное множество.

####Программная реализация графа
Каждое ребро графа представлены классом `Edge`, содержащим:
* `int from` - стартовая вершина
* `int to` - конечная вершина
* `KeyType weight` - вес ребра

Граф представлен классом `Graph`, содержащим следующие поля:
* `int n` - количество вершина графа.
* `int m` - количество ребер графа.
* `Edge<KeyType>** edges` - массив ребер.
* `int current` - текущее ребро.

Класс содержит следующие методы:
* `CreateGraph(KeyType, KeyType)` - создает граф (на вход принимается минимальное и максимальное значение веса ребра).
* `Push(int, int, KeyType)` - добавляет ребро с заданными условиями (откуда, куда, вес).
* `Remove(int, int)` - удаляет заданное ребро
* `GetCount()` - возвращает количество вершин
* `GetEdgeSize()` - возвращает максимальное количество рёбер.
* `GetRealSize()` - возвращает реальное количество рёбер.
* `GetEdge(int)` - возвращает ребро.
* `GetWeight(int, int)` - возвращает вес ребра
* `Print()` - вывод граф на экран

##Заключение
В ходе лабораторной работы:
* Были реализованы структуры данных:
 - "D-куча"
 - "Бинарное поисковое дерево"
 - "Таблица"
 - "Просматриваемая таблица"
 - "Упорядоченная таблица"
 - "Приоритетная очередь на основе D-кучи"
 - "Приоритетная очередь на основе бинарного поискового дерева"
 - "Приоритетная очередь на основе упорядоченой таблицы"
 - "Графы"
 - "Разделенные множества"
с использованием шаблонных классов. 
* Написано тестирующее приложение, которое покрывает все методы, используемые в указанных классах. Все тесты успешно пройдены. 
* Написаны консольные приложения:
 - Пирамидальная сортировка массива.
 - алгоритм Дейкстры для поиска кратчайших путей от любой стартовой вершины связного неориентированного взвешенного графа без петель, реализованного на основе приоритетной очереди на базe D-кучи.
 - алгоритм Краскала для построения минимального остовного дерева неориентированного взвешенного графа без петель, реализованного на основе приоритетных очередях на базе D-кучи, бинарного поискового дерева и упорядоченной таблицы.

##Литература
1. Кормен Т., Лейзерсон Ч., Риверст Р., Штайн К. Алгоритмы. Построение и анализ. - М.: Издательский дом "Вильямс". - 2005. - 1290с.
2. Алексеев В.Е., Таланов В.А. Графы. Модели вычислений. Структуры данных: Учебник. – Нижний Новгород: Изд-во ННГУ, 2005. 307 с.


